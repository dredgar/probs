#include <cstdio>
#include <queue>

typedef long long ll;
const int N = 200003;
struct Node {
    struct Edge *e;
    Node *gas;
    int d;
} g[N];
struct Edge {
    Node *u, *v;
    int w;
    Edge *next;
    Edge(Node *_u, Node *_v, int _w) : u(_u), v(_v), w(_w), next(_u->e) {
        _u->e = this;
    }
};
struct Triple {
    int u, v, w;
} es[N];
struct Dij {
    Node *u;
    int d;
    bool operator < (const Dij &b) const {
        return d > b.d;
    }
};
std::priority_queue<Dij> q;
void dijkstra() {
    while (!q.empty()) {
        Node *u = q.top().u;
        q.pop();
        for (Edge *e = u->e; e; e = e->next) {
            Node *v = e->v;
            if (v->d > u->d + e->w) {
                v->d = u->d + e->w;
                v->gas = u->gas;
                q.push((Dij){v, v->d});
            }
        }
    }
}
struct DisjointSet() {
    int n, fa[N];
    void init(int _n) {
        n = _n;
        for (int i = 1; i <= n; ++i)
            fa[i] = i;
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    void unite(int x, int y) {
        fa[find(x)] = find(y);
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
} ds;
struct Opt {
    int u, v, ind;
    ll w;
    Opt() {}
    Opt(int _u, int _v, ll _w, int _i) : u(_u), v(_v), ind(_i), w(_w) {}
} qwq[N + N];
int main() {
    static int n, s, m, t, i, u, v, w, qcnt, ans[N];
    scanf("%d%d%d", &n, &s, &m);
    for (i = 1; i <= n; ++i) {
        scanf("%d", &u);
        g[u].d = 0;
        g[u].gas = &g[u];
        q.push((Dij){&g[u], 0});
    }
    for (i = 1; i <= m; ++i) {
        scanf("%d%d%d", &u, &v, &w);
        es[i] = (Triple){u, v, w};
        new Edge(&g[u], &g[v], w);
        new Edge(&g[v], &g[u], w);
    }
    dijkstra();
    for (i = 1; i <= n; ++i)
        g[i].e = NULL;
    for (i = 1; i <= m; ++i) {
        u = es[i].u, v = es[i].v, w = es[i].w;
        if (g[u].gas == g[v].gas)
            continue;
        qwq[++qcnt] = Opt(u, v, w + g[u].d + g[v].d, -1);
    }
    scanf("%d", &t);
    for (i = 1; i <= t; ++i) {
        scanf("%d%d%d", u, &v, &w);
        qwq[++qcnt] = Opt(u, v, w, i);
    }
    std::sort(qwq + 1, qwq + qcnt + 1);
    ds.init(n);
    for (i = 1; i <= qcnt; ++i) {
        Opt &q = qwq[i];
        if (q.ind == -1)
            ds.unite(q.u, q.v);
        else
            ans[q.ind] = ds.same(q.u, q.v);
    }
    for (i = 1; i <= t; ++i)
        puts(ans[i] ? "TAK" : "NIE");

    return 0;
}
